module Single_Cycle_CPU (
    input wire MAX10_CLK1_50,        // Clock input from DE-10 Lite FPGA
    input wire reset                 // Reset signal (active high)
);


wire [4:0] rom_address;
wire [31:0] instruction;  // Explicit declaration for instruction signal
wire alu_src;
wire write_en;
wire [4:0] selected_register;
wire [31:0] alu_result;  // Explicit declaration for alu_result signal
wire zero_flag;  // Explicit declaration for zero_flag signal
wire [4:0] read_register_1;  // Explicit declaration for read_register_1 signal
wire [4:0] read_register_2;  // Explicit declaration for read_register_2 signal
wire write_data;  // Explicit declaration for write_data signal
wire [31:0] read_data_1;  // Explicit declaration for read_data_1 signal
wire [31:0] read_data_2;  // Explicit declaration for read_data_2 signal
wire [4:0] ram_address;
wire [3:0] alu_control;
wire [31:0] ram_result;
wire mem_reg_selector;
wire [31:0] mem_reg_result;
wire ram_read_enable;
wire rom_read_enable;
wire ram_write_enable;

// Instantiate the Program Counter module
ProgramCounter program_counter (
    .clk(MAX10_CLK1_50),
    .reset(reset),
    .pc(rom_address)
);


ROM32x32 rom(
    .address(rom_address),
    .clock(MAX10_CLK1_50),
	 .rden(rom_read_enable),
    .q(instruction)
);

// Connect RegisterFile's read_data_1 and read_data_2 to read_register_1 and read_register_2
RegisterFile register_file (
    .clk(MAX10_CLK1_50),
    .reset(reset),
    .read_register_1(read_register_1),
    .read_register_2(read_register_2),
    //.write_register_file(selected_register),
	 .reg_write_address(selected_register),
    .write_enable(mem_reg_selector),
    .write_data(mem_reg_result),
    .read_data_1(alu_operand_A), // Connect read_data_1
    .read_data_2(alu_operand_B)  // Connect read_data_2
);


// Instantiate the ALU module and connect the ALU control signal
ALU my_alu (
    .clk(MAX10_CLK1_50),
    .operand_A(alu_operand_A),
    .operand_B(operand_B),
    .alu_control(alu_control),
    .alu_result(alu_result),
    .zero_flag(zero_flag),
	 .ram_address(ram_address)
);

// Instantiate the ControlUnit module
ControlUnit control_unit (
    .clk(MAX10_CLK1_50),
    .reset(reset),
    .instruction(instruction),
    .alu_op(alu_control),
	 .alu_src(alu_src),
	 .reg_write_enable(write_en),
	 .mem_to_reg(mem_reg_selector), 
	 .read_register_1(read_register_1),
	 .read_register_2(read_register_2),
	 .write_register(write_register),
	 .rom_read_enable(rom_read_enable),
    .ram_read_enable(ram_read_enable),
	 .ram_write_enable(ram_write_enable)

);

ALUOperandBMux alu_operand(
    .sign_extended_imm(sign_extended_imm),
    .read_register_2(alu_operand_B),
    .select(alu_src),  // Control signal to select the input (0 for sign_extended_imm, 1 for read_register_2)
    .operand_b(operand_B)
);

WriteRegisterMux write_reg(
    .write_register(write_register),
    .read_register_2(read_register_2),
    .reg_write_enable(write_en),
    .selected_register(selected_register)
);

SignExtendImmediate sign_extend(
    .instruction(instruction[15:0]),
    .sign_extended_imm(sign_extended_imm)
);


RAM32x1024 ram(
	.address(ram_address),
	.clock(MAX10_CLK1_50),
	.data(alu_operand_B),
	.rden(ram_read_enable),
	.wren(ram_write_enable),
	.q(ram_result)
	);
	
	
DataMUX mem_reg_select(
    .ram_result(ram_result),
    .alu_result(alu_result),
    .mux_select(mem_reg_selector),  // MUX selection control
    .data_output(mem_reg_result)
);

	

endmodule